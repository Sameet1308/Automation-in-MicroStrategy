"""
app_combo_planner.py

Goal (based on your entitlement model):
- If an AD group is mapped to apps {A,B,C}, every user in that group is treated as a user of A,B,C.
- If a user belongs to multiple groups, they use the UNION of apps mapped to those groups.

Output:
- One consolidated CSV.
- One row per user.
- Users who become removable in combo (wave) k are listed with combo metadata.
- Leftover users (not removed by generated combos) are listed with status=LEFTOVER.

How combos (waves) are chosen:
- Maintain ConvertedApps (starts empty).
- For each remaining user, Need(u) = UserApps(u) - ConvertedApps.
- Group remaining users by identical Need-set.
- Pick the Need-set shared by the largest number of users as next combo (tie-break: smaller Need-set, then lexical).
- Convert those apps (add to ConvertedApps).
- Remove all users whose full UserApps(u) is now subset of ConvertedApps (true license reduction).
- Repeat until no more progress or max combos reached.

USAGE:
1) Edit CONFIG section below:
   - INPUT_CSV_PATH, OUTPUT_CSV_PATH
   - USER_COL, GROUP_COL, APP_COL (or keep placeholders; you said you'll change)
2) Run:
   python app_combo_planner.py
"""

import os
from typing import Dict, Set, List, Tuple
import pandas as pd

# ============================================================
# CONFIG (EDIT THESE)
# ============================================================
INPUT_CSV_PATH = r"/path/to/your/input.csv"
OUTPUT_CSV_PATH = r"/path/to/output/app_combos_full_report.csv"

# Column names in your CSV (edit these to match your file)
USER_COL = "user"
GROUP_COL = "ad_group"
APP_COL = "application"

# Optional: limit number of combos (None = no limit)
MAX_COMBOS = None

# Console preview rows
PREVIEW_ROWS = 25

# If True, users with no derived apps will be kept as LEFTOVER (recommended)
KEEP_ZERO_APP_USERS_AS_LEFTOVER = True
# ============================================================


def _safe_mkdir_for_file(filepath: str) -> None:
    out_dir = os.path.dirname(os.path.abspath(filepath))
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir, exist_ok=True)


def _clean_series(s: pd.Series) -> pd.Series:
    return s.astype(str).str.strip()


def _build_user_groups_and_group_apps_from_one_csv(
    df: pd.DataFrame,
    user_col: str,
    group_col: str,
    app_col: str
) -> Tuple[Dict[str, Set[str]], Dict[str, Set[str]]]:
    """
    Build from ONE CSV:
      user_groups: user -> set(AD groups)
      group_apps:  AD group -> set(apps)

    Works if the file contains repeated triples or partial repeated relationships.
    """
    df = df[[user_col, group_col, app_col]].copy()

    # user -> groups
    ug = df.dropna(subset=[user_col, group_col])[[user_col, group_col]].copy()
    ug[user_col] = _clean_series(ug[user_col])
    ug[group_col] = _clean_series(ug[group_col])
    ug = ug[(ug[user_col] != "") & (ug[group_col] != "")]

    user_groups: Dict[str, Set[str]] = {}
    for u, g in zip(ug[user_col], ug[group_col]):
        user_groups.setdefault(u, set()).add(g)

    # group -> apps
    ga = df.dropna(subset=[group_col, app_col])[[group_col, app_col]].copy()
    ga[group_col] = _clean_series(ga[group_col])
    ga[app_col] = _clean_series(ga[app_col])
    ga = ga[(ga[group_col] != "") & (ga[app_col] != "")]

    group_apps: Dict[str, Set[str]] = {}
    for g, a in zip(ga[group_col], ga[app_col]):
        group_apps.setdefault(g, set()).add(a)

    return user_groups, group_apps


def _derive_user_apps(user_groups: Dict[str, Set[str]], group_apps: Dict[str, Set[str]]) -> Dict[str, Set[str]]:
    """
    Your entitlement logic:
      UserApps(user) = union of apps across all groups user belongs to.
    """
    user_apps: Dict[str, Set[str]] = {}
    for u, groups in user_groups.items():
        apps = set()
        for g in groups:
            apps |= group_apps.get(g, set())
        user_apps[u] = apps
    return user_apps


def _pick_next_combo_by_max_need(
    remaining_users: Set[str],
    user_apps: Dict[str, Set[str]],
    converted_apps: Set[str]
) -> Tuple[frozenset, List[str]]:
    """
    Need(u) = UserApps(u) - ConvertedApps
    Group by identical Need-set and pick the Need-set with maximum user count.

    Tie-breakers:
      1) higher user count
      2) smaller Need-set (fewer apps to convert)
      3) lexical stability on Need-set
    """
    need_to_users: Dict[frozenset, List[str]] = {}

    for u in remaining_users:
        need = frozenset(user_apps.get(u, set()) - converted_apps)
        if len(need) == 0:
            continue
        need_to_users.setdefault(need, []).append(u)

    if not need_to_users:
        return frozenset(), []

    def sort_key(item):
        need_set, users = item
        return (-len(users), len(need_set), ",".join(sorted(need_set)))

    chosen_need, users_list = sorted(need_to_users.items(), key=sort_key)[0]
    return chosen_need, sorted(users_list)


def run_planner_single_output() -> None:
    if not os.path.exists(INPUT_CSV_PATH):
        raise FileNotFoundError(f"Input CSV not found: {INPUT_CSV_PATH}")

    df = pd.read_csv(INPUT_CSV_PATH)

    for c in [USER_COL, GROUP_COL, APP_COL]:
        if c not in df.columns:
            raise ValueError(
                f"Missing column '{c}' in input CSV. "
                f"Available columns: {list(df.columns)}"
            )

    user_groups, group_apps = _build_user_groups_and_group_apps_from_one_csv(
        df, USER_COL, GROUP_COL, APP_COL
    )
    user_apps = _derive_user_apps(user_groups, group_apps)

    all_users = set(user_apps.keys())
    remaining_users = set(all_users)
    converted_apps: Set[str] = set()

    # Data-quality bucket: users with no derived apps (group->app missing or incomplete)
    zero_app_users = {u for u in remaining_users if len(user_apps.get(u, set())) == 0}

    combo_rank = 0
    cumulative_removed = 0
    out_rows = []

    def fully_covered(users_subset: Set[str]) -> Set[str]:
        # user removable if ALL their apps are in converted_apps
        return {u for u in users_subset if user_apps.get(u, set()).issubset(converted_apps)}

    while True:
        if MAX_COMBOS is not None and combo_rank >= MAX_COMBOS:
            break

        selectable_users = set(remaining_users)
        if KEEP_ZERO_APP_USERS_AS_LEFTOVER:
            selectable_users -= zero_app_users

        if not selectable_users:
            break

        chosen_need, _users_with_same_need = _pick_next_combo_by_max_need(
            selectable_users, user_apps, converted_apps
        )
        if not chosen_need:
            break

        combo_rank += 1
        combo_apps = set(chosen_need)
        combo_apps_list = ",".join(sorted(combo_apps))

        # Snapshot need before conversion (for transparency)
        need_before = {
            u: sorted(list(user_apps.get(u, set()) - converted_apps))
            for u in selectable_users
        }

        # Convert these apps (apps won't repeat in later combos)
        converted_apps |= combo_apps

        # True license reduction: remove all users now fully covered
        removable_now = fully_covered(selectable_users)
        removed_this_combo = sorted(list(removable_now))

        remaining_users -= set(removed_this_combo)
        cumulative_removed += len(removed_this_combo)

        for u in removed_this_combo:
            out_rows.append({
                "combo_rank": combo_rank,
                "combo_apps_list": combo_apps_list,
                "combo_apps_count": len(combo_apps),
                "combo_users_removed_in_this_combo": len(removed_this_combo),
                "cumulative_users_removed": cumulative_removed,
                "user": u,
                "user_apps_list": ",".join(sorted(user_apps.get(u, set()))),
                "user_need_before_combo": ",".join(need_before.get(u, [])),
                "user_ad_groups_list": ",".join(sorted(user_groups.get(u, set()))),
                "status": "REMOVED",
                "leftover_reason": ""
            })

        # Stop if a combo converts apps but removes nobody (avoid looping)
        if len(removed_this_combo) == 0:
            break

    # Add leftovers
    for u in sorted(list(remaining_users)):
        apps = user_apps.get(u, set())
        if len(apps) == 0:
            reason = "No applications derived from group mappings (likely missing group->app mapping in data)."
        else:
            reason = "Not removed by generated combos; would require converting additional remaining apps."

        out_rows.append({
            "combo_rank": "",
            "combo_apps_list": "",
            "combo_apps_count": "",
            "combo_users_removed_in_this_combo": "",
            "cumulative_users_removed": cumulative_removed,
            "user": u,
            "user_apps_list": ",".join(sorted(apps)),
            "user_need_before_combo": ",".join(sorted(list(apps - converted_apps))),
            "user_ad_groups_list": ",".join(sorted(user_groups.get(u, set()))),
            "status": "LEFTOVER",
            "leftover_reason": reason
        })

    out_df = pd.DataFrame(out_rows)
    _safe_mkdir_for_file(OUTPUT_CSV_PATH)
    out_df.to_csv(OUTPUT_CSV_PATH, index=False)

    # Console summary + sample preview
    print("\n==================== SUCCESS ====================")
    print(f"Input CSV : {INPUT_CSV_PATH}")
    print(f"Output CSV: {OUTPUT_CSV_PATH}")
    print("-------------------------------------------------")
    print(f"Total users          : {len(all_users)}")
    print(f"Removed users        : {cumulative_removed}")
    print(f"Leftover users       : {len(all_users) - cumulative_removed}")
    print(f"Combos generated     : {combo_rank}")
    print(f"Total apps converted : {len(converted_apps)}")
    print("=================================================\n")

    if not out_df.empty:
        pd.set_option("display.max_colwidth", 80)
        pd.set_option("display.width", 220)
        print(f"Sample output preview (first {min(PREVIEW_ROWS, len(out_df))} rows):")
        print(out_df.head(PREVIEW_ROWS).to_string(index=False))
        print("\nTip: In Excel, filter by combo_rank to see the user list removable for that combo.")
    else:
        print("No output rows produced. Check input data quality.")


if __name__ == "__main__":
    run_planner_single_output()